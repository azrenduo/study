# css 选择器

## 简单选择器

### ID 选择器

```css
#demoid {
}
```

### 类选择器

```css
.democlass {
}
```

### 元素选择器

```css
p {
}
```

### 通配符选择器

```css
* {
}
```

### 属性选择器

```css
[id="Attribute"] {
}
```

### 伪类选择器

选中某些元素的某种状态 通常配合其他选择器使用

1. 鼠标悬停状态：hover
2. 鼠标按下状态：active
3. 超链接未访问时的状态：link
4. 超链接访问过后的状态：visited
   书写顺序：link > visited > hover > active

```css
:hover {
}
:active {
}
:visited {
}
:link {
}
:visited {
}
```

### 伪元素选择器

before
after
可以使用 content 属性添加文本内容，并且 content 只能在伪元素中使用

```css
::before {
  content: "此处添加文本内容";
}
::after {
}
```

## 选择器组合

### 后代选择器

```css
div span {
}
```

### 直接子元素选择器

```css
div > em {
}
```

### 并列选择器

```css
div.demo {
}

em,
strong,
span {
}
```

# 层叠

声明冲突：同一个样式，多次应用到同一个元素

层叠(权重计算)：解决声明冲突的过程，浏览器自动处理

## 1. 比较重要性

重要性从高到低：

> 作者样式表：开发者书写的样式
> 1、 作者样式表中的 !importtant 样式
> 2、 作者样式表中普通样式
> 3、 浏览器默认样式表

## 2. 比较特殊性

看选择器

总体规则：选择器选中的范围越窄，越特殊

具体规则：通过选择器，计算出 4 位数(x x x x)

1. 千位：如果是内联样式,记 1，否则记 0
2. 百位：等于选择器中所有 id 选择器的数量
3. 十位：等于选择器中所有类选择器、属性选择器、伪类选择器的数量
4. 各位：等于选择器中所有元素选择器、伪元素选择器的数量

## 3. 比较源次序

书写靠后胜出

# 继承

子元素会继承父元素某些 css 属性

通常，与文字内容相关的属性都能被继承

# 属性值的计算过程

一个元素一个元素一次渲染，顺序安装也页面文档的树形目录结构进行

渲染每个元素的前提条件：该元素的所有 CSS 属性必须有值

一个元素，从所有属性都没有值，到所有属性都有值，这个计算过程，叫做属性值计算过程

无属性值

1. 确定声明值：参考样式表中没有冲突的声明，作为 CSS 属性值
2. 层叠冲突：对样式表有冲突的声明使用层叠规则，确定 CSS 属性值
3. 使用继承：对仍然没有值的书写，若可以继承，则继承父元素的值
4. 使用默认值：对仍然没有值的书写，使用默认值

## 特殊的两个 CSS 取值

- inherit：手动(强制)继承，将父元素的值取出应用到该元素
- initial：初始值，将该属性设置为默认值

```css
a {
  color: inherit; /*强制继承*/
  color: initial; /*初始化*/
}
```

# 盒模型

box：盒子，每个元素在页面中都会生成一个矩形区域(盒子)
盒子类型：

1. 行盒，display 等于 inline 的元素
2. 块盒，display 等于 block 的元素

行盒在页面中不换行，块盒独占一行
display 默认值为 inline
浏览器默认样式表设置块盒：容器元素、h1~h6，p
常见行盒：span，a，img，video，audio

## 盒子的组成部分

无论是行盒、还是块盒，都是由西安几个部分组成，从内到外分别是：

1. 内容 content
   width、height，设置的是盒子内容的宽高
   内容部分通常叫做整个盒子的**内容盒 content-box**

2. 填充(内边距) padding
   盒子边框到盒子内容的距离
   padding-left、padding-right、padding-top、padding-button

填充区+内容区=填充盒

1. 边框 border
   边框 = 边框样式 + 边框宽度 + 边框颜色
   边框样式：border-style
   边框宽度：border-width
   边框颜色：border-color

边框+填充区+内容区= **边框盒**

4. 外边距 margin
   边框到其他盒子的距离

盒子简写(速写)属性书写方法

属性名：(上) (右) (下) (左)

属性名:(上) (左右) (下)

属性名：(上下) (左右)

属性名:(上下左右)

# 盒模型应用

## 改变宽高范围

默认情况下，width 和 height 设置的是内容盒的宽高。

> 页面重构师：将 psd 文件(设计稿)制作为静态页面

衡量设计稿尺寸的时候，往往使用的是边框盒，但设置 width 盒 height，则设置的是内容盒

1. 精确计算
2. CSS3：box-sizing

## 改变背景覆盖范围

默认情况下，背景覆盖边框盒
可以通过 background-clip 进行修改

## 溢出处理

overflow，控制内容溢出边框盒的处理方式

## 断词规则

world-break，会影响文字在什么位置被截断换号

- normal：普通。cjk 字符(文字位置截断)，非 CJK 字符(单词位置截断)

- break-all：截断所有。所有字符都在文字出截断

- keep-all：保持所有。所有文字都在单词截断

## 空白处理

单行文本空白处理

```css
whit-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
```

多行文本空白处理使用 js 处理

# 行盒盒模型

常见的行盒：包含具体内容的元素

span、strong、em、i、img、video、audio

## 显著特点

1. 盒子沿着内容沿伸
2. 行盒不能设置宽高

调整行盒的宽高，应该使用字体大小、行高、字体类型，间接调整。

3. 内边距(padding)

水平方向有效，垂直方向仅会影响背景，不会实际战局空间。

4. 边框(border)

水平方向有效，垂直方向仅会影响背景，不会实际战局空间。

5. 外边距(marging)

水平方向有效，垂直方向仅会影响背景，不会实际战局空间。

## 行块盒

display:inline-block 的盒子

1. 不独占一行
2. 盒模型中所有尺寸都有效

## 空白折叠

发生在行盒(行块盒)内部 或 行盒(行块盒)之间

## 可替换元素 和 非可替换元素

大部分元素，页面上显示的结果，取决于元素内容，称为**非可替换元素**

少部分元素，页面上显示的结果，取决于元素属性，称为**可替换元素**

可替换元素:img、video、audio

绝大部分可替换元素均为行盒。

可替换元素类似于行块盒，盒模型中所有尺寸都有效。

- object-fit
1. contain 保持比例，保留所有图片信息
2. cover 保持比例，牺牲图片信息
3. file 不保持比例，填充图案

# 常规流

盒模型：规定单个盒子的规则

视觉格式化模型(布局规则)：页面中的多个盒子排列规则

视觉格式化模型，大体上将页面中盒子的排列方法分为三种方式：

1. 常规流
2. 浮动
3. 定位

## 常规流布局

常规流、文档流、普通文档流、常规文档流

所有元素，默认情况下，都属于常规流布局

总体规则：块和独占一行，行盒水平依次排列

包含块(containing block):每个盒子都有他的包含块，包含块决定了盒子的排列区域(活动范围)

绝大部分情况下：盒子的包含块，为其父元素的内容盒

**块盒**
1. 每个块和的总宽度，必须刚好等于包含块的宽度

宽度的默认值是auto

margin的取值也可以是auto，默认值0

auto：将剩余空间吸收

width吸收能力强于margin

若宽度、边框、内边距、外边距计算后，仍然有剩余空间，该剩余空间被margin-right全部吸收

在常规流中，块盒在其包含块居中，可以定宽、然后左右margin设置为auto。

2. 每个块盒垂直方向上的auto值

height:auto,适应内容的高度

margin:auto,表示0

3. 百分比取值

padding、宽高、margin可以取值为百分比

以上所有百分比相对于包含块的宽度。

高度的百分比：
1). 包含块的高度是取决于子元素的高度，设置百分比无效
2). 包含块的高度不取决于子元素的高度，百分比当对于父元素的高度

4. 上下外边距合并

两个常规流块盒，上下外边距相邻，会进行合并

两个外边距去最大值

